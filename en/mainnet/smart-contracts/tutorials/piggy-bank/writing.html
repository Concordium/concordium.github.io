



<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1. Writing the piggy bank smart contract &mdash; Concordium  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/concordium-logo-no-text.svg"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="2. Testing the piggy bank smart contract" href="testing.html" />
    <link rel="prev" title="The piggy bank smart contract" href="index.html" />
<link href="../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #4486AB" >
          


          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/concordium-logo-mainnet.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
<nav class="sidebar-top-menu">
    <a href="../../../net/index.html" class="" ><i class="icon fa fa-connectdevelop"></i> Mainnet</a>
    <a href="../../index.html" class="active"> <i class="icon fa fa-file-o"></i> Smart Contracts </a>
</nav>

        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">General</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../general/introduction.html">Introduction to smart contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general/contract-module.html">Smart contract modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general/contract-instances.html">Smart contract instances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general/contract-schema.html">Smart contract schemas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general/resource-accounting.html">Resource accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general/develop-contracts.html">Developing smart contracts in Rust</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The piggy bank smart contract</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. Writing the piggy bank smart contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing.html">2. Testing the piggy bank smart contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#support-feedback">Support &amp; Feedback</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Contract development guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guides/setup-tools.html">Install tools for development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/setup-contract.html">Setting up a smart contract project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/compile-module.html">Compile a Rust smart contract module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/unit-test-contract.html">Unit test a contract in Rust</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/custom-errors.html">Return custom errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/local-simulate.html">Locally simulate contract functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/build-schema.html">Build a contract schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/no-std.html">Build using <code class="docutils literal notranslate"><span class="pre">no_std</span></code></a></li>
</ul>
<p class="caption"><span class="caption-text">On-chain guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guides/deploy-module.html">Deploy a smart contract module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/initialize-contract.html">Initialize a smart contract instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/interact-instance.html">Interact with a smart contract instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/inspect-instance.html">Inspect a smart contract instance</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../references/schema-json.html">Schema JSON representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/simulate-context.html">Simulation contexts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/host-fns.html">Contract host functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/references-on-chain.html">References on-chain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/local-settings.html">Local settings</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/Concordium/concordium-rust-smart-contracts">Rust contract examples (repo)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/">concordium-std</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Concordium</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Concordium Smart Contract Documentation</a> &raquo;</li>
        
          <li><a href="index.html">The piggy bank smart contract</a> &raquo;</li>
        
      <li><span class="section-number">1. </span>Writing the piggy bank smart contract</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Concordium/concordium.github.io/blob/mainnet/source/smart-contracts/tutorials/piggy-bank/writing.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-the-piggy-bank-smart-contract">
<span id="piggy-bank-writing"></span><h1><span class="section-number">1. </span>Writing the piggy bank smart contract<a class="headerlink" href="#writing-the-piggy-bank-smart-contract" title="Permalink to this headline">¶</a></h1>
<p>This is the first <a class="reference internal" href="index.html#piggy-bank"><span class="std std-ref">part of a tutorial</span></a> on smart contract
development. In this part we will focus on how to write a smart contract in the
<a class="reference external" href="https://www.rust-lang.org/">Rust</a> programming language using the <code class="docutils literal notranslate"><span class="pre">concordium-std</span></code> library.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The reader is assumed to have basic knowledge of what a blockchain and smart
contract is, and some experience with <a class="reference external" href="https://www.rust-lang.org/">Rust</a>.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#preparation" id="id5">Preparation</a></p></li>
<li><p><a class="reference internal" href="#bringing-in-the-standard-library" id="id6">Bringing in the standard library</a></p></li>
<li><p><a class="reference internal" href="#piggy-bank-contract" id="id7">Piggy bank contract</a></p></li>
<li><p><a class="reference internal" href="#specifying-the-state" id="id8">Specifying the state</a></p></li>
<li><p><a class="reference internal" href="#setting-up-a-piggy-bank" id="id9">Setting up a piggy bank</a></p>
<ul>
<li><p><a class="reference internal" href="#the-init-macro" id="id10">The <code class="docutils literal notranslate"><span class="pre">#[init]</span></code> macro</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#define-interaction-with-piggy-banks" id="id11">Define interaction with piggy banks</a></p>
<ul>
<li><p><a class="reference internal" href="#the-receive-macro" id="id12">The <code class="docutils literal notranslate"><span class="pre">#[receive(...)]</span></code> macro</a></p></li>
<li><p><a class="reference internal" href="#inserting-gtu" id="id13">Inserting GTU</a></p></li>
<li><p><a class="reference internal" href="#smashing-a-piggy-bank" id="id14">Smashing a piggy bank</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#support-feedback" id="id15">Support &amp; Feedback</a></p></li>
</ul>
</div>
<div class="section" id="preparation">
<h2><span class="section-number">1.1. </span>Preparation<a class="headerlink" href="#preparation" title="Permalink to this headline">¶</a></h2>
<p>Before we start, make sure to have the necessary tooling for building Rust
contracts.
The guide <a class="reference internal" href="../../guides/setup-tools.html#setup-tools"><span class="std std-ref">Install tools for development</span></a> will show you how to do this.
Also, make sure to have a text editor for writing Rust.</p>
<p>We also need to set up a new smart contract project.
Follow the guide <a class="reference internal" href="../../guides/setup-contract.html#setup-contract"><span class="std std-ref">Setting up a smart contract project</span></a> and return to this point afterwards.</p>
<p>We are now ready for writing a smart contract for the Concordium blockchain!</p>
</div>
<div class="section" id="bringing-in-the-standard-library">
<h2><span class="section-number">1.2. </span>Bringing in the standard library<a class="headerlink" href="#bringing-in-the-standard-library" title="Permalink to this headline">¶</a></h2>
<p>The source code of our smart contract is going to be in the <code class="docutils literal notranslate"><span class="pre">src</span></code> directory,
which already contains the file <code class="docutils literal notranslate"><span class="pre">lib.rs</span></code>, assuming you follow the above guide
to set up your project.
Open <code class="docutils literal notranslate"><span class="pre">src/lib.rs</span></code> in your editor and you’ll see some code for writing tests,
which you can delete for now. We will come back to tests later in this tutorial.</p>
<p>First, we bring everything from the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/index.html"><code class="docutils literal notranslate"><span class="pre">concordium-std</span></code></a> library into scope,
by adding the line:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">concordium_std</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This library contains everything needed for writing our smart contract. It
provides convenient wrappers around some low-level operations making our code
more readable, and although it is not strictly necessary to use this, it will
save a lot of code for the vast majority of contract developers.</p>
</div>
<div class="section" id="piggy-bank-contract">
<h2><span class="section-number">1.3. </span>Piggy bank contract<a class="headerlink" href="#piggy-bank-contract" title="Permalink to this headline">¶</a></h2>
<p>The contract we are going to build in this tutorial is going to act as a classic
piggy bank. Everyone should be able to put money in the form of GTU into it, but only the owner
can smash it and retrieve the GTU inside. Once the piggy bank has been
smashed, it should not be possible to add GTU to it.</p>
<p>The piggy-bank smart contract is going to contain a function for setting up a
new piggy bank and two functions for updating a piggy bank; one is for everyone
to use for inserting GTU, the other is for the owner to smash the piggy bank and
prevent further interaction.</p>
</div>
<div class="section" id="specifying-the-state">
<h2><span class="section-number">1.4. </span>Specifying the state<a class="headerlink" href="#specifying-the-state" title="Permalink to this headline">¶</a></h2>
<p>To implement a piggy bank we need to keep track of the amount of GTU it holds,
and we need to know whether it has been smashed. The blockchain will take care
of the first task for us since the chain keeps track of the balance of each smart-contract
instance. Therefore, we only need to maintain whether the piggy bank has been smashed,
which we do as part of the smart-contract <em>state</em>.</p>
<p>In Rust we represent this state as an enum, with a variant for the piggy bank
being intact and one for it being smashed:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">PiggyBankState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Intact</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Smashed</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since the state of our smart contract is going to be stored on the blockchain,
we need to specify how the contract state should be serialized.
When using the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/index.html"><code class="docutils literal notranslate"><span class="pre">concordium-std</span></code></a> library, this all boils down to our type
for the contract state having to implement the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/trait.Serialize.html"><code class="docutils literal notranslate"><span class="pre">Serialize</span></code></a> trait exposed by
<a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/index.html"><code class="docutils literal notranslate"><span class="pre">concordium-std</span></code></a>.</p>
<p>Luckily the library already contains implementations for most of the primitives
and standard types in <a class="reference external" href="https://www.rust-lang.org/">Rust</a>, and a <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/derive.Serialize.html">procedural macro for deriving</a>
<a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/trait.Serialize.html"><code class="docutils literal notranslate"><span class="pre">Serialize</span></code></a> for most cases of enums and structs:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[derive(Serialize)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">PiggyBankState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Intact</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Smashed</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Later in this tutorial, we will also need to check the state for equality, so we also
derive the trait implementation for <code class="docutils literal notranslate"><span class="pre">PartialEq</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[derive(Serialize, PartialEq, Eq, Debug)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">PiggyBankState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Intact</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Smashed</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-a-piggy-bank">
<h2><span class="section-number">1.5. </span>Setting up a piggy bank<a class="headerlink" href="#setting-up-a-piggy-bank" title="Permalink to this headline">¶</a></h2>
<p>Time to write the function for setting up a new piggy bank, which in turn means
specifying the init function for a smart contract.
A smart contract must specify an init function, which is called when new
instances of the contract are created, and is used to set up the initial state of
the contract instance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <a class="reference external" href="https://www.rust-lang.org/">Rust</a> developer could compare init functions with the convention of
having a <code class="docutils literal notranslate"><span class="pre">new</span></code> function for types, and the smart contract as the type.</p>
<p>If you have experience with object-oriented programming, it might help to
think of a smart contract as a <em>class</em>, the init function as a
<em>constructor</em> and smart contract instances as <em>objects</em>.</p>
</div>
<p>In the case of the piggy bank; the initial state should be set to <code class="docutils literal notranslate"><span class="pre">Intact</span></code>.</p>
<div class="section" id="the-init-macro">
<h3><span class="section-number">1.5.1. </span>The <code class="docutils literal notranslate"><span class="pre">#[init]</span></code> macro<a class="headerlink" href="#the-init-macro" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference external" href="https://www.rust-lang.org/">Rust</a> an init function can be specified as a regular function that is annotated
with a procedural macro from <code class="docutils literal notranslate"><span class="pre">concordium-std</span></code> called <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.init.html"><code class="docutils literal notranslate"><span class="pre">#[init]</span></code></a>.
This allows us to create a new piggy bank as follows:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[init(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">piggy_init</span><span class="p">(</span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasInitContext</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">InitResult</span><span class="o">&lt;</span><span class="n">PiggyBankState</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The macro saves you the details of setting up the function as an external
function and serializing the state to bytes. The macro also provides an interface for
accessing information about the context of the smart-contract call.</p>
<p>The init function requires a name for the smart contract, which we choose to be
<code class="docutils literal notranslate"><span class="pre">&quot;PiggyBank&quot;</span></code>. The name <a class="footnote-reference brackets" href="#valid-name" id="id4">1</a> is used as part of the exported
function, and is how we distinguish this smart contract from other smart
contracts in our module.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[init(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">)]</span><span class="w"></span>
</pre></div>
</div>
<p>The init function takes a single argument, <code class="docutils literal notranslate"><span class="pre">ctx:</span> <span class="pre">&amp;impl</span> <span class="pre">HasInitContext</span></code>,
which is a zero-sized struct with a number of getter functions for accessing
information about the current context, such as the account that invoked this contract, the
supplied arguments and information about the state of the blockchain.</p>
<p>The return type of our function is <code class="docutils literal notranslate"><span class="pre">InitResult&lt;PiggyBankState&gt;</span></code>, which is an
alias for <code class="docutils literal notranslate"><span class="pre">Result&lt;PiggyBankState,</span> <span class="pre">Reject&gt;</span></code>. The returned state is serialized
and set as the initial state of the smart contract.</p>
<p>Initializing our piggy bank state to be <code class="docutils literal notranslate"><span class="pre">Intact</span></code> is then straightforward:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="nb">Ok</span><span class="p">(</span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>A more complex smart contract would take a parameter, and check during
initialization that everything is set up as expected, but more about this
later.</p>
<dl class="footnote brackets">
<dt class="label" id="valid-name"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>The contract name is only allowed to consist of ASCII alphanumeric or
punctuation characters, and is not allowed to contain the <code class="docutils literal notranslate"><span class="pre">.</span></code> symbol.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="define-interaction-with-piggy-banks">
<h2><span class="section-number">1.6. </span>Define interaction with piggy banks<a class="headerlink" href="#define-interaction-with-piggy-banks" title="Permalink to this headline">¶</a></h2>
<p>We have now defined how instances of our smart contract are created, and the
smart contract is in principle a valid contract.
However, we would also like to define how to interact with instances of our
contract.
Specifically how to add GTU to it and how to smash a piggy bank.</p>
<p>A smart contract can expose zero or more functions for interacting with an
instance.
These functions are called receive functions, and can read and
write to the state of the instance, read the state of the blockchain and
return a description of actions to be executed on-chain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a <a class="reference external" href="https://www.rust-lang.org/">Rust</a> developer, receive functions are like methods with
a mutable reference to <cite>self</cite>.</p>
<p>A continuation of the analogy to object-oriented programming:
receive functions correspond to object methods.</p>
</div>
<div class="section" id="the-receive-macro">
<h3><span class="section-number">1.6.1. </span>The <code class="docutils literal notranslate"><span class="pre">#[receive(...)]</span></code> macro<a class="headerlink" href="#the-receive-macro" title="Permalink to this headline">¶</a></h3>
<p>In Rust, receive functions can be specified using the procedural macro
<a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.receive.html"><code class="docutils literal notranslate"><span class="pre">#[receive]</span></code></a>, which, like <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.init.html"><code class="docutils literal notranslate"><span class="pre">#[init]</span></code></a>, is used to annotate a function and sets up an
external function and supplies us with an interface for accessing the context.
But, unlike the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.init.html"><code class="docutils literal notranslate"><span class="pre">#[init]</span></code></a> macro, the function for <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.receive.html"><code class="docutils literal notranslate"><span class="pre">#[receive]</span></code></a> is also supplied with
a mutable reference to the current state of the instance:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[receive(contract = </span><span class="s">&quot;MyContract&quot;</span><span class="cp">, name = </span><span class="s">&quot;some_interaction&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">some_receive</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">MyContractState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;Implement&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">contract</span></code> attribute supplies the name of the contract to the macro.
This name should match the name in the corresponding attribute in <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.init.html"><code class="docutils literal notranslate"><span class="pre">#[init]</span></code></a>
(<code class="docutils literal notranslate"><span class="pre">&quot;PiggyBank&quot;</span></code> in our case). It also requires a name to identify this
particular receive function using <code class="docutils literal notranslate"><span class="pre">name</span></code>. The name and contract attributes
each have to be unique within a smart contract module.</p>
<p>The return type of the function is <code class="docutils literal notranslate"><span class="pre">ReceiveResult&lt;A&gt;</span></code>, which is an alias for
<code class="docutils literal notranslate"><span class="pre">Result&lt;A,</span> <span class="pre">Reject&gt;</span></code>.
Here, <code class="docutils literal notranslate"><span class="pre">A</span></code> implements <code class="docutils literal notranslate"><span class="pre">HasActions</span></code>, which exposes functions for creating
various <a class="reference internal" href="../../general/contract-instances.html#action-descriptions"><span class="std std-ref">actions</span></a>.</p>
<p>In this contract we will use the <strong>Accept</strong> and <strong>Simple Transfer</strong> actions.</p>
</div>
<div class="section" id="inserting-gtu">
<h3><span class="section-number">1.6.2. </span>Inserting GTU<a class="headerlink" href="#inserting-gtu" title="Permalink to this headline">¶</a></h3>
<p>The first interaction we will specify for our piggy bank is how to insert GTU into it.
We start with defining a receive function as:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[receive(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">, name = </span><span class="s">&quot;insert&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">piggy_insert</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">PiggyBankState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;Implement&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here, we make sure that the contract name matches the one we use for the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.init.html"><code class="docutils literal notranslate"><span class="pre">#[init]</span></code></a> macro,
and we name the receive function <code class="docutils literal notranslate"><span class="pre">insert</span></code>.
The function will not need to use the <code class="docutils literal notranslate"><span class="pre">_ctx</span></code> context, so by convention, we
prefix the argument with <code class="docutils literal notranslate"><span class="pre">_</span></code>.</p>
<p>In the function body we have to make sure that the piggy bank is still intact: the
smart contract should reject any messages if the piggy bank is smashed:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Smashed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Reject</span>::<span class="n">default</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since returning early is a common pattern when writing smart contracts and in
<a class="reference external" href="https://www.rust-lang.org/">Rust</a> in general, <code class="docutils literal notranslate"><span class="pre">concordium-std</span></code> exposes a <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/macro.bail.html"><code class="docutils literal notranslate"><span class="pre">bail!</span></code></a> macro:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Smashed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">bail</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Furthermore, we can use the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/macro.ensure.html"><code class="docutils literal notranslate"><span class="pre">ensure!</span></code></a> macro for returning early depending on a condition:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>From this line, we will know that the state of the piggy bank is intact and all
we have left to do is accept the incoming amount of GTU.
The GTU balance is maintained by the blockchain, so there is no need for us to
maintain this in our contract. The contract just needs to produce the <strong>Accept</strong> action
using the generic <code class="docutils literal notranslate"><span class="pre">A</span></code> (more on that below):</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="nb">Ok</span><span class="p">(</span><span class="n">A</span>::<span class="n">accept</span><span class="p">())</span><span class="w"></span>
</pre></div>
</div>
<p>So far we have the following definition of the receive function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[receive(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">, name = </span><span class="s">&quot;insert&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">piggy_insert</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">PiggyBankState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">A</span>::<span class="n">accept</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Our definition of how to add GTU to the piggy bank is almost done, but one important detail is
missing.
If we were to send GTU to the current smart contract, the transaction
would be rejected. This is a safety feature of <code class="docutils literal notranslate"><span class="pre">concordium-std</span></code>,
which, by default, prevents init and receive functions
from accepting GTU.</p>
<p>The reason for rejecting GTU by default is to reduce the risk of creating a smart
contract that accepts GTU without retrieving it: any GTU passed to such a contract
would be <em>inaccessible forever</em>.</p>
<p>To be able to accept GTU, we have to add the <code class="docutils literal notranslate"><span class="pre">payable</span></code> attribute to the <code class="docutils literal notranslate"><span class="pre">#[receive]</span></code> macro.
Now the function is required to
take an extra argument <code class="docutils literal notranslate"><span class="pre">amount:</span> <span class="pre">Amount</span></code>, which represents the amount that is passed to the receive
function.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#[receive(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">, name = </span><span class="s">&quot;insert&quot;</span><span class="cp">, payable)]</span><span class="w"></span>
</span><span class="k">fn</span> <span class="nf">piggy_insert</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="hll"><span class="w">    </span><span class="n">_amount</span>: <span class="nc">Amount</span><span class="p">,</span><span class="w"></span>
</span><span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">PiggyBankState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">A</span>::<span class="n">accept</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As mentioned above, since the blockchain is maintaining the balance of our smart contract, we
do not have to do that ourselves, and the <code class="docutils literal notranslate"><span class="pre">amount</span></code> is not used by our contract.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">payable</span></code> attribute also exists for the <code class="docutils literal notranslate"><span class="pre">#[init]</span></code> macro.</p>
</div>
</div>
<div class="section" id="smashing-a-piggy-bank">
<h3><span class="section-number">1.6.3. </span>Smashing a piggy bank<a class="headerlink" href="#smashing-a-piggy-bank" title="Permalink to this headline">¶</a></h3>
<p>Now that we can insert GTU into a piggy bank, we are only left to define how to
smash one.
Just to recap, we only want the owner of the piggy bank (smart contract
instance) to be able to call this and only if the piggy bank has not already
been smashed.
It should set its state to be smashed and transfer all of its GTU to the owner.</p>
<p>Again we use the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/attr.receive.html"><code class="docutils literal notranslate"><span class="pre">#[receive]</span></code></a> macro to define the smash function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[receive(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">, name = </span><span class="s">&quot;smash&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">piggy_smash</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">PiggyBankState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;Implement&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We ensure that the contract name matches the one of our smart contract and we choose
to name this function <code class="docutils literal notranslate"><span class="pre">smash</span></code>.</p>
<p>To access the contract owner, we use a getter function exposed by the context
<code class="docutils literal notranslate"><span class="pre">ctx</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>This returns the account address of the contract instance owner, i.e. the
account that created the smart contract instance by invoking the
init function.</p>
<p>Similarly, the context has a getter function to access the sender of the current
message that triggered this receive function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">sender</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">sender</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>Since both accounts and smart-contract instances are capable of sending messages,
<code class="docutils literal notranslate"><span class="pre">sender</span></code> is of the  <code class="docutils literal notranslate"><span class="pre">Address</span></code> type, which is either an account
address or a contract instance address.</p>
<p>To compare the <code class="docutils literal notranslate"><span class="pre">sender</span></code> with <code class="docutils literal notranslate"><span class="pre">owner</span></code> we can use the <a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/enum.Address.html#method.matches_account"><code class="docutils literal notranslate"><span class="pre">matches_account</span></code></a>
function defined on the <code class="docutils literal notranslate"><span class="pre">sender</span></code>, which will only return true if the sender is
an account address that is equal to the owner:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="n">matches_account</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Next we ensure that the state of the piggy bank is <code class="docutils literal notranslate"><span class="pre">Intact</span></code>, just like previously:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>At this point we know, the piggy bank is still intact and the sender is the
owner, meaning we now get to the smashing part:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Smashed</span><span class="w"></span>
</pre></div>
</div>
<p>Since the state is a mutable reference, we can simply mutate it to be
<code class="docutils literal notranslate"><span class="pre">Smashed</span></code>, preventing anyone from inserting any more GTU.</p>
<p>Lastly we need to empty the piggy bank. To do that, we transfer all the GTU
of the smart-contract instance to an account.</p>
<p>To transfer GTU from a smart contract instance we create an
action for a simple transfer, again using the generic <code class="docutils literal notranslate"><span class="pre">A</span></code>.
To construct a simple transfer we need to provide the address of the receiving
account and the amount to be transferred.
In our case the receiver is the owner of the piggy bank and the amount is the
entire balance of the piggy bank.</p>
<p>The context has a getter function for reading
the current balance of the smart contract instance, which is called
<a class="reference external" href="https://docs.rs/concordium-std/latest/concordium_std/trait.HasReceiveContext.html#tymethod.self_balance"><code class="docutils literal notranslate"><span class="pre">self_balance</span></code></a>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">self_balance</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>We already have a variable with the address of the contract owner, so we can
construct and return the action for a simple transfer:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="nb">Ok</span><span class="p">(</span><span class="n">A</span>::<span class="n">simple_transfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span><span class="w"> </span><span class="n">balance</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The final definition of our “smash” receive function is then:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[receive(contract = </span><span class="s">&quot;PiggyBank&quot;</span><span class="cp">, name = </span><span class="s">&quot;smash&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">piggy_smash</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">HasActions</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ctx</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">HasReceiveContext</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">PiggyBankState</span><span class="p">,</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ReceiveResult</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sender</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">sender</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="n">matches_account</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">ensure</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Intact</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PiggyBankState</span>::<span class="n">Smashed</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">self_balance</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">A</span>::<span class="n">simple_transfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span><span class="w"> </span><span class="n">balance</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We now have all the parts for our piggy bank smart contract. Before we move on
to testing it, we check that it builds by running:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>cargo concordium build
</pre></div>
</div>
<p>This should succeed if everything is set up correctly. Otherwise, compare your
code with the one found <a class="reference external" href="https://github.com/Concordium/concordium-rust-smart-contracts/blob/main/examples/piggy-bank/part1/src/lib.rs">here</a>.</p>
</div>
</div>
<div class="section" id="support-feedback">
<h2><span class="section-number">1.7. </span>Support &amp; Feedback<a class="headerlink" href="#support-feedback" title="Permalink to this headline">¶</a></h2>
<p>If you have questions or feedback, join us on <a class="reference external" href="https://support.concordium.software/">Discourse</a>, or contact us at <a class="reference external" href="mailto:support&#37;&#52;&#48;concordium&#46;software">support<span>&#64;</span>concordium<span>&#46;</span>software</a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
<a href="http://creativecommons.org/licenses/by-sa/4.0/">
    <img style="margin-bottom: 0.5em" src="../../../_static/cc-sa-by.png" />
</a>

    <p>
        &#169; Copyright 2021, Concordium Software ApS.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: mainnet
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/en/mainnet/">mainnet</a></dd>
      <dd><a href="/en/testnet/">testnet</a></dd>
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TE81YY48VB"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}

gtag('consent', 'default', { 'ad_storage': 'denied', 'analytics_storage': loadChoice() ? 'granted' : 'denied' });
gtag('js', new Date());
gtag('config', 'G-TE81YY48VB', {'anonymize_ip': true});

// Save the choice in a cookie
function storeChoice(granted) {
    document.cookie = "cookie-consent=" + granted
}

// Look for a cookie storing the previous choice of the user.
// Returns undefined if no choice was stored, otherwise a boolean for whether the
// user gave consent.
function loadChoice() {
    if (!document.cookie.includes("cookie-consent=")) {
        return undefined;
    }
    return document.cookie.includes("cookie-consent=true")
}

// Removes the cookie consent banner
function removeCookieConsentBanner() {
    document.getElementById("cookie-consent").remove()
}

// Called by the cookie consent banner if granted permission
function consentGranted() {
    storeChoice(true)
    gtag('consent', 'update', { 'ad_storage': 'denied', 'analytics_storage': 'granted' });
    removeCookieConsentBanner()
}

// Called by the cookie consent banner if denied permission
function consentDenied() {
    storeChoice(false)
    removeCookieConsentBanner()
}


</script>
<div id="cookie-consent" class="consent">
    <p>We use cookies to ensure that we give you the best experience on our website, but only if you grant us the permission</p>
    <button onclick="consentGranted()">Allow</button>
    <button onclick="consentDenied()">Disallow</button>
    <a href="https://concordium.com/privacy-policy/">Privacy policy</a>
</div>
<script>
    const stored = loadChoice();
    if (stored !== undefined) {
        removeCookieConsentBanner()
    }
</script>


</body>
</html>