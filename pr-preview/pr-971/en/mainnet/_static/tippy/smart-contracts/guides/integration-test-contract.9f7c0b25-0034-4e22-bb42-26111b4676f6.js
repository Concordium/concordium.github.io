selector_to_html = {"a[href=\"#invoke-contract-entrypoints\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Invoke contract entrypoints<a class=\"headerlink\" href=\"#invoke-contract-entrypoints\" title=\"Link to this heading\">#</a></h2><p>The method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_invoke\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_invoke</span></code></a> is similar to <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_update\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_update</span></code></a> in that it allows you to execute contract entrypoints.\nThe difference is that an invoke is <em>not a transaction and is not persisted</em>, so contract states, account balances, etc. remain unchanged after the call.\nFor seasoned Rust programmers, that is easily seen by its function signature, which takes an immutable reference to the chain (<code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;self</span></code>), as opposed to the mutable reference (<code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;mut</span> <span class=\"pre\">self</span></code>) used in the update method.\nThe primary purpose of <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_invoke\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_invoke</span></code></a> is to get the return value of an entrypoint.</p><p>It has all the same parameters as a contract update, except for the <code class=\"docutils literal notranslate\"><span class=\"pre\">signer</span></code>, which is only needed for transactions.\nWhile the result of the invocation isn\u2019t saved on the chain, all the entities referred, e.g. contracts and accounts, must still exist in the <code class=\"docutils literal notranslate\"><span class=\"pre\">chain</span></code>.</p>", "a[href=\"#update-contract-entrypoints\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Update contract entrypoints<a class=\"headerlink\" href=\"#update-contract-entrypoints\" title=\"Link to this heading\">#</a></h2><p>With the contract initialized, you are ready to update it with the chain method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_update\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_update</span></code></a>, which has the following parameters:</p>", "a[href=\"#initialize-contracts\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialize contracts<a class=\"headerlink\" href=\"#initialize-contracts\" title=\"Link to this heading\">#</a></h2><p>With the module deployed, you are ready to initialize a contract with the chain method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_init\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_init</span></code></a>.\nThe method has the following parameters:</p>", "a[href=\"migrate-contracts.html#migrate-contracts-for-std-8-1\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Migrate contracts for <code class=\"docutils literal notranslate\"><span class=\"pre\">concordium-std</span></code> 8.1<a class=\"headerlink\" href=\"#migrate-contracts-for-concordium-std-8-1\" title=\"Link to this heading\">#</a></h1><p>With the <a class=\"reference external\" href=\"https://docs.rs/concordium-std/latest/concordium_std\"><code class=\"docutils literal notranslate\"><span class=\"pre\">concordium_std</span></code></a> version <code class=\"docutils literal notranslate\"><span class=\"pre\">8.1</span></code> release, writing and reading smart contracts is easier than ever before.\nThe new version of the standard library reduces the need for generics and traits in your init and receive methods.\nThese generics and traits were there to support testing with the <a class=\"reference external\" href=\"https://docs.rs/concordium-std/8.1/concordium_std/test_infrastructure\"><code class=\"docutils literal notranslate\"><span class=\"pre\">test_infrastructure</span></code></a>, which has been deprecated in favor of the <a class=\"reference external\" href=\"https://docs.rs/concordium-std-derive/latest/concordium_smart-contract-testing\"><code class=\"docutils literal notranslate\"><span class=\"pre\">concordium-smart-contract-testing</span></code></a> library.</p><p>This guide shows you how to migrate your contract code to use the simpler concrete types and use fewer generics.</p>", "a[href=\"#data-for-assertions\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Data for assertions<a class=\"headerlink\" href=\"#data-for-assertions\" title=\"Link to this heading\">#</a></h2><p>This section covers how to get the data most commonly used for assertions in smart contract integration tests.</p>", "a[href=\"#transfers-to-accounts\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Transfers to accounts<a class=\"headerlink\" href=\"#transfers-to-accounts\" title=\"Link to this heading\">#</a></h3><p>One of the trace elements from the previous section, <code class=\"docutils literal notranslate\"><span class=\"pre\">Transferred</span></code>, describes a transfer from an contract to an account.\nWith the helper method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeSuccess.html#method.account_transfers\"><code class=\"docutils literal notranslate\"><span class=\"pre\">account_transfers</span></code></a>, you can get an iterator over all transfers to accounts in the order that they occured in a single call of <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_update\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_update</span></code></a> or <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_invoke\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_invoke</span></code></a>.</p><p>Example:</p>", "a[href=\"#contract-trace-elements\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Contract trace elements<a class=\"headerlink\" href=\"#contract-trace-elements\" title=\"Link to this heading\">#</a></h3><p>The contract trace elements describe the contract calls, transfers to accounts, module upgrades, and the success of these during a <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_update\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_update</span></code></a> or <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_invoke\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_invoke</span></code></a>.</p><p>The struct returned on success from these calls has an <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeSuccess.html#method.effective_trace_elements\"><code class=\"docutils literal notranslate\"><span class=\"pre\">effective_trace_elements</span></code></a> method which returns a list of all the <em>effective</em> elements in the order that they occurred.\nTo understand what <em>effective</em> refers to, an example is useful:</p>", "a[href=\"unit-test-contract.html#unit-test-contract\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Unit test a contract in Rust<a class=\"headerlink\" href=\"#unit-test-a-contract-in-rust\" title=\"Link to this heading\">#</a></h1><p>This guide describes how to write unit tests for a smart contract written in\nRust.\nFor information about how to test a smart contract Wasm module, see <a class=\"reference internal\" href=\"local-simulate.html#local-simulate\"><span class=\"std std-ref\">Locally simulate contract functions</span></a>.</p><p>A smart contract in Rust is written as a library and you can unit test it like a\nlibrary by annotating functions with a <code class=\"docutils literal notranslate\"><span class=\"pre\">#[test]</span></code> attribute.</p>", "a[href=\"#balances\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Balances<a class=\"headerlink\" href=\"#balances\" title=\"Link to this heading\">#</a></h3><p>You can query the balance of accounts and contracts with the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Chain</span></code></a>.\nSince accounts can stake part of their balance and also receive transfers with a schedule, their balance has three parts.</p>", "a[href=\"#deploy-modules\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Deploy modules<a class=\"headerlink\" href=\"#deploy-modules\" title=\"Link to this heading\">#</a></h2><p>Deploying smart contract modules is a two-step process.\nFirst, you load the module with the function <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/fn.module_load_v1.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">module_load_v1</span></code></a>, then you deploy it to the chain with the method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.module_deploy_v1\"><code class=\"docutils literal notranslate\"><span class=\"pre\">module_deploy_v1</span></code></a>.\nLoading as a separate step allows you to reuse the loaded module across multiple tests for efficiency.</p><p>The module to load must be a <code class=\"docutils literal notranslate\"><span class=\"pre\">wasm</span></code> module compiled with <code class=\"docutils literal notranslate\"><span class=\"pre\">cargo</span> <span class=\"pre\">concordium</span> <span class=\"pre\">build</span></code> or, if using cargo concordium version 2.9.0+, <code class=\"docutils literal notranslate\"><span class=\"pre\">cargo</span> <span class=\"pre\">concordium</span> <span class=\"pre\">test</span> <span class=\"pre\">--out</span> <span class=\"pre\">path/to/wasm/module</span></code>.\nUsing the test command is ideal, as that will both compile the module <em>and</em> run the tests.\nBy compiling the module every time, you ensure that the tests run on the newest version of your code.\nFor example, for <code class=\"docutils literal notranslate\"><span class=\"pre\">cargo</span> <span class=\"pre\">concordium</span> <span class=\"pre\">test</span> <span class=\"pre\">--embed-schema</span> <span class=\"pre\">--out</span> <span class=\"pre\">my_module.wasm.v1</span></code>, you write:</p>", "a[href=\"#return-values\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Return values<a class=\"headerlink\" href=\"#return-values\" title=\"Link to this heading\">#</a></h3><p>Both <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_update\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_update</span></code></a> and <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.contract_invoke\"><code class=\"docutils literal notranslate\"><span class=\"pre\">contract_invoke</span></code></a> have return values when they succeed, or if they fail in a specific way.\nOn success, you can access the return value directly, for example <code class=\"docutils literal notranslate\"><span class=\"pre\">update.return_value</span></code>, which is a byte array, <code class=\"docutils literal notranslate\"><span class=\"pre\">Vec&lt;u8&gt;</span></code>.\nBut the methods can fail in multiple ways, for example if the contract runs out of energy or it panics, and the return value is only available when the contract rejects on its own.\nThe helper method <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeError.html#method.return_value\"><code class=\"docutils literal notranslate\"><span class=\"pre\">return_value</span></code></a> on the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeError.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">ContractInvokeError</span></code></a> struct tries to extract the return value and returns an <code class=\"docutils literal notranslate\"><span class=\"pre\">Option&lt;Vec&lt;u8&gt;&gt;</span></code>.\nIt is common to deserialize the return values into structered data and thus both the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeSuccess.html#method.parse_return_value\">success</a> and <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.ContractInvokeError.html#method.parse_return_value\">error</a> types have helper methods called <code class=\"docutils literal notranslate\"><span class=\"pre\">parse_return_value</span></code>, which returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">Result&lt;T,</span> <span class=\"pre\">ParseError&gt;</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">T</span></code> is the type you want to parse.\nFor example:</p>", "a[href=\"#integration-test-a-contract-in-rust\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Integration test a contract in Rust<a class=\"headerlink\" href=\"#integration-test-a-contract-in-rust\" title=\"Link to this heading\">#</a></h1><p>This guide describes how to write <em>integration tests</em> in Rust for your smart contracts using the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/\">Concordium smart contract testing library</a>.</p>", "a[href=\"#creating-accounts\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Creating accounts<a class=\"headerlink\" href=\"#creating-accounts\" title=\"Link to this heading\">#</a></h2><p>The next step is to create one or more <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Account.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Account</span></code></a> entities and add them to the chain.</p><p>Accounts have multiple constructors that allow you to specify more details.\nThe simplest one is <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Account.html#method.new\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Account::new</span></code></a>, which takes an <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.AccountAddress.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">AccountAddress</span></code></a> and a total balance of the account.\nOnce constructed, use the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.create_account\"><code class=\"docutils literal notranslate\"><span class=\"pre\">create_account</span></code></a> method to add it to the chain.\nThis step is important, as simply constructing an <code class=\"docutils literal notranslate\"><span class=\"pre\">Account</span></code> does not make the chain aware of it.</p>", "a[href=\"#creating-a-chain\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Creating a chain<a class=\"headerlink\" href=\"#creating-a-chain\" title=\"Link to this heading\">#</a></h2><p>The primary construct used for testing is the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Chain</span></code></a> type, which you should only create one of per test.\nIt represents the blockchain and has methods for creating accounts and deploying and working with contracts.</p><p>Use the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/struct.Chain.html#method.new\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Chain::new</span></code></a> method to create a chain with default settings.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
