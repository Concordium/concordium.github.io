selector_to_html = {"a[href=\"#deploy-the-smart-contract\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Deploy the smart contract<a class=\"headerlink\" href=\"#deploy-the-smart-contract\" title=\"Link to this heading\">#</a></h3><p>If you don\u2019t have your own testnet node running, Concordium provides a running testnet gRPC node that is available at <code class=\"docutils literal notranslate\"><span class=\"pre\">node.testnet.concordium.com</span></code> on port 20000 (gRPCv2 and gRPC-web). You can use this node for API calls of <em>chain methods only</em>. This node is maintained by Concordium, but Concordium does not guarantee availability. The status of this node is available on the <a class=\"reference external\" href=\"https://status.testnet.concordium.software\">Testnet status page</a>. For some use cases you might need to run your own local node due to the limitations of this one.</p><p>Run the command below to deploy the smart contract. This command is structured to use the Concordium testnet node described above. If you are using your own local node, adjust the command accordingly.</p>", "a[href=\"#smart-contract-implementation-for-fungible-tokens\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Smart contract implementation for fungible tokens<a class=\"headerlink\" href=\"#smart-contract-implementation-for-fungible-tokens\" title=\"Link to this heading\">#</a></h1><p>For your token contract, use the <a class=\"reference external\" href=\"https://github.com/Concordium/concordium-rust-smart-contracts/tree/main/examples/cis2-multi\">cis2-multi contract from Concordium\u2019s example smart contract repository on GitHub</a>. You will make some minor modifications to it in this tutorial, such as the maximum supply of your token, circulating supply, and a burn function. Basically, no one will be able to mint a token again if it already met the maximum supply. Your token will be deflationary in that sense. Burning a token will not affect the circulating supply; if you want, you can adjust the corresponding function so it could affect circulating supply.</p>", "a[href=\"#build-the-smart-contract\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Build the smart contract<a class=\"headerlink\" href=\"#build-the-smart-contract\" title=\"Link to this heading\">#</a></h3><p>Run the command below to create a Wasm compiled build file of your smart contract. It is a good habit to create a folder for the output files. For example, here the user created a parent folder named <cite>dist</cite> and a child folder named <cite>fungible</cite> inside of it.</p><p>You can embed the schema file in the module, which means you don\u2019t have to call it again and again for your future function calls. To build the contract and embed the schema file, use the command below.</p>", "a[href=\"#mint-function\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Mint function<a class=\"headerlink\" href=\"#mint-function\" title=\"Link to this heading\">#</a></h2><p>As discussed earlier, you have new inputs in <code class=\"docutils literal notranslate\"><span class=\"pre\">MintParams</span></code>, so when you get the JSON parameter as the input you expect an object that holds both metadata and another struct that holds the maximum supply and the amount to be minted. That is why there is <code class=\"docutils literal notranslate\"><span class=\"pre\">token_info</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">token_info.0</span></code> will represent the <code class=\"docutils literal notranslate\"><span class=\"pre\">TokenMetadata</span></code> struct and <code class=\"docutils literal notranslate\"><span class=\"pre\">token_info.1</span></code> will represent <code class=\"docutils literal notranslate\"><span class=\"pre\">TokenParams</span></code>.</p><p>Unlike the NFT tutorials, this time you actually want the token to be mintable with the same ID. Just keep it less than the maximum value. That is why you commented on the first ensure statement which makes sure that the tokenId is unique for a token.</p>", "a[href=\"#initialize-the-smart-contract\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Initialize the smart contract<a class=\"headerlink\" href=\"#initialize-the-smart-contract\" title=\"Link to this heading\">#</a></h3><p>Using the Module reference hash value, create a contract instance with the command below. This command is structured to use the Concordium testnet node described above. If you are using your own local node, adjust the command accordingly.</p>", "a[href=\"../nft-minting/upload-nft.html#upload-nft\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Upload the NFT<a class=\"headerlink\" href=\"#upload-the-nft\" title=\"Link to this heading\">#</a></h1><p>Now you need to upload your asset and give it metadata. For this tutorial you will use the InterPlanetary File System (IPFS).</p>", "a[href=\"#minting\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Minting<a class=\"headerlink\" href=\"#minting\" title=\"Link to this heading\">#</a></h2><p>First, add the changes to your contract for the minting parameters that you require when <code class=\"docutils literal notranslate\"><span class=\"pre\">mint()</span></code> is invoked. It will ask for the minting amount and <code class=\"docutils literal notranslate\"><span class=\"pre\">max_supply</span></code>. Create a struct called <code class=\"docutils literal notranslate\"><span class=\"pre\">TokenParams</span></code> and add this to the tokens tree as shown below.</p>", "a[href=\"mint-xfer.html#mint-xfer-ft\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Mint, transfer, and burn fungible tokens<a class=\"headerlink\" href=\"#mint-transfer-and-burn-fungible-tokens\" title=\"Link to this heading\">#</a></h1><p>Now you are ready to mint your new tokens. Before minting, look at the minting parameters in the JSON file below. You need to specify the owner, then the token data following with its tokenID, metadata location on IPFS with the URL that you got when you uploaded the metadata file, hash value of it, amount to be minted, and maximum supply number. In this case, it uses tokenID <code class=\"docutils literal notranslate\"><span class=\"pre\">01</span></code>, and mint <code class=\"docutils literal notranslate\"><span class=\"pre\">110</span></code> tokens initially with a maximum supply of 1000.</p>", "a[href=\"#contract-mint-function\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Contract mint function<a class=\"headerlink\" href=\"#contract-mint-function\" title=\"Link to this heading\">#</a></h3><p>You will compare the circulating supply, maximum supply and the amount to be minted. If the mint amount + circulating supply is more than the maximum supply you will not allow minting.</p><p>In the <code class=\"docutils literal notranslate\"><span class=\"pre\">contact_mint</span></code> function below see the following changes accordingly. First, the parameters are read as a form of JSON. See the <code class=\"docutils literal notranslate\"><span class=\"pre\">MintParams</span></code> struct for the details of the parameters. In the first <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span></code> clause, it first checks if the token exists in the state. If not, meaning you are going to mint this token for the first time, you will set the maximum supply by calling the <code class=\"docutils literal notranslate\"><span class=\"pre\">set_max_supply()</span></code> function. The max_supply value is in the <code class=\"docutils literal notranslate\"><span class=\"pre\">TokenParam</span></code> struct as the second item.</p>", "a[href=\"#build-deploy-and-initialize\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Build, deploy, and initialize<a class=\"headerlink\" href=\"#build-deploy-and-initialize\" title=\"Link to this heading\">#</a></h2><p>Now that you have finished coding your smart contract you can build, deploy, and initialize it. You will use the <code class=\"docutils literal notranslate\"><span class=\"pre\">concordium-client</span></code> to build it, then deploy it to the testnet, and finally, mint/transfer/burn your token.</p><p>First, create a metadata file. You will use it to pick an image for it, and naming and description. One thing that is important to note is the <strong>unique</strong> flag. Since this is not an NFT, you should set it to <strong>false</strong>. Then upload it to the IPFS and save the CID address. For information about how to do this, see <a class=\"reference internal\" href=\"../nft-minting/upload-nft.html#upload-nft\"><span class=\"std std-ref\">Upload the NFT</span></a>. You will use it while minting the token.</p>", "a[href=\"#state-mint-function\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">State mint function<a class=\"headerlink\" href=\"#state-mint-function\" title=\"Link to this heading\">#</a></h3><p>There is only one minor change needed in the state\u2019s mint function, which is increasing the circulating supply when a token is minted. You are keeping the circulating balance in the <code class=\"docutils literal notranslate\"><span class=\"pre\">token_balance</span></code> map, using the <code class=\"docutils literal notranslate\"><span class=\"pre\">token_id</span></code> key of the map to call the value and update it, which you do in the last statement.</p>", "a[href=\"#contract-burn-function\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Contract burn function<a class=\"headerlink\" href=\"#contract-burn-function\" title=\"Link to this heading\">#</a></h3><p>Based on the requirements, you should be able to call tokens. In order to do that, you\u2019ll be adding the <code class=\"docutils literal notranslate\"><span class=\"pre\">contract</span> <span class=\"pre\">burn()</span></code> function in the existing cis2-multi contract.</p><p>But first, you need another parameter to get the information about the tokens that will be burned. Create a struct, called <code class=\"docutils literal notranslate\"><span class=\"pre\">BurnParams</span></code>; you will need <code class=\"docutils literal notranslate\"><span class=\"pre\">token_id</span></code> and the amount to be burned.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
