selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Trie\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/320px-Trie_example.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>In computer science, a <b>trie</b>, also called <b>digital tree</b> or <b>prefix tree</b>, is a type of <span><i>k</i>-ary</span> search tree, a tree data structure used for locating specific keys from within a set. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Trie#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/320px-Trie_example.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>In computer science, a <b>trie</b>, also called <b>digital tree</b> or <b>prefix tree</b>, is a type of <span><i>k</i>-ary</span> search tree, a tree data structure used for locating specific keys from within a set. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>", "a[href=\"../guides/compile-module.html#compile-module\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Compile a Rust smart contract module<a class=\"headerlink\" href=\"#compile-a-rust-smart-contract-module\" title=\"Link to this heading\">#</a></h1><p>This guide will show you how to compile smart contract module written in Rust to\na Wasm module.</p>", "a[href=\"contract-module.html#contract-module\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Smart contract modules<a class=\"headerlink\" href=\"#smart-contract-modules\" title=\"Link to this heading\">#</a></h1><p>Smart contracts are deployed on the chain in <em>smart contract modules</em>. A smart contract module is often referred to simply as a <em>module</em>.</p><p>A module can contain one or more smart contracts, allowing code to be shared\namong the contracts and can optionally contain <a class=\"reference internal\" href=\"contract-schema.html#contract-schema\"><span class=\"std std-ref\">contract schemas</span></a> and verification data.</p>", "a[href=\"#avoid-creating-black-holes\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Avoid creating black holes<a class=\"headerlink\" href=\"#avoid-creating-black-holes\" title=\"Link to this heading\">#</a></h2><p>A smart contract is not required to use the amount of CCD send to it, and by\ndefault a smart contract does not define any behavior for emptying the balance\nof an instance, in case someone were to send some CCD.\nThese CCD would then be forever <em>lost</em>, and there would be no way to recover\nthem.</p><p>Therefore it is good practice for smart contracts that are not dealing with CCD,\nto ensure the sent amount of CCD is zero and reject any invocations which are\nnot.\nUsing the <code class=\"docutils literal notranslate\"><span class=\"pre\">#[init(...)]</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">#[receive(...)]</span></code> macros will help you in this\nendeavor, as they will cause functions to return a <code class=\"docutils literal notranslate\"><span class=\"pre\">NotPayble</span></code> error if\nthey receive a non-zero amount of CCD.\nTo enable receiving CCD for a function, use the <a class=\"reference external\" href=\"https://docs.rs/concordium-std-derive/latest/concordium_std_derive/attr.init.html#payable-make-function-accept-an-amount-of-ccd\"><code class=\"docutils literal notranslate\"><span class=\"pre\">payable</span></code></a> attribute in the\nmacro, e.g.: <code class=\"docutils literal notranslate\"><span class=\"pre\">#[init(...,</span> <span class=\"pre\">payable)]</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">#[receive(...,</span> <span class=\"pre\">payable)]</span></code>.</p>", "a[href=\"#develop-smart-contracts-in-rust\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Develop smart contracts in Rust<a class=\"headerlink\" href=\"#develop-smart-contracts-in-rust\" title=\"Link to this heading\">#</a></h1><p>On the Concordium blockchain smart contracts are deployed as Wasm modules, but\nWasm is designed primarily as a compilation target and is not convenient to\nwrite by hand.\nInstead you can write your smart contracts in the <a class=\"reference external\" href=\"https://www.rust-lang.org/\">Rust</a> programming language, which\nhas good support for compiling to Wasm.</p><p>Smart contracts do not have to be written in Rust.\nThis is simply the first SDK provided.\nManually written Wasm, or Wasm compiled from C, C++, <a class=\"reference external\" href=\"https://github.com/AssemblyScript\">AssemblyScript</a>, and\nothers, is equally valid on the chain, as long as it adheres to the <a class=\"reference internal\" href=\"contract-module.html#wasm-limitations\"><span class=\"std std-ref\">Wasm\nlimitations Concordium imposes</span></a>.</p>", "a[href=\"contract-module.html#wasm-limitations\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Limitations<a class=\"headerlink\" href=\"#limitations\" title=\"Link to this heading\">#</a></h3><p>The blockchain environment is very particular in the sense that each node must\nbe able to execute the contract in exactly the same way, using exactly the same\namount of resources. Otherwise, nodes would fail to reach consensus on the\nstate of the chain. For this reason, smart contracts need to be written in a restricted\nsubset of Wasm.</p>", "a[href=\"#serializable-state-and-parameters\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Serializable state and parameters<a class=\"headerlink\" href=\"#serializable-state-and-parameters\" title=\"Link to this heading\">#</a></h3><p>On-chain, the state of an instance is represented as a <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Trie\">prefix tree</a>, where nodes in the tree can have data in the\nform of a byte array.\nThe instance uses functions provided by the host environment to create, delete,\nand find nodes in the tree.\nThe host also provides functions for reading, writing, and resizing the byte array\nheld by a particular node in the tree.</p><p>For simple contracts, the complete contract state is stored in the root node of\nthe state tree. For this to work, the state must implement the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">Serialize</span></code> trait which contains (de-)serialization functions.\nThe <code class=\"docutils literal notranslate\"><span class=\"pre\">concordium_std</span></code> crate includes this trait and implementations for most\ntypes in the Rust standard library.\nIt also includes macros for deriving the trait for user-defined structs and\nenums.</p>", "a[href=\"#work-with-parameters\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Work with parameters<a class=\"headerlink\" href=\"#work-with-parameters\" title=\"Link to this heading\">#</a></h3><p>Parameters to the init and receive functions are represented as byte arrays.\nWhile the byte arrays can be used directly, they can also be deserialized into\nstructured data.</p><p>The simplest way to deserialize a parameter is through the <a class=\"reference external\" href=\"https://docs.rs/concordium-std/latest/concordium_std/trait.Get.html#tymethod.get\">get()</a> function of\nthe <a class=\"reference external\" href=\"https://docs.rs/concordium-std/latest/concordium_std/trait.Get.html\">Get</a> trait.</p>", "a[href=\"#build-a-smart-contract-module-with-cargo-concordium\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Build a smart contract module with <code class=\"docutils literal notranslate\"><span class=\"pre\">cargo-concordium</span></code><a class=\"headerlink\" href=\"#build-a-smart-contract-module-with-cargo-concordium\" title=\"Link to this heading\">#</a></h2><p>The Rust compiler has good support for compiling to Wasm using the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">wasm32-unknown-unknown</span></code> target.\nHowever, even when compiling with <code class=\"docutils literal notranslate\"><span class=\"pre\">--release</span></code> the resulting build includes\nlarge sections of debug information in custom sections, which are not useful for\nsmart contracts on-chain.</p><p>To optimize the build and allow for new features such as embedding schemas, Concordium\nrecommends using <code class=\"docutils literal notranslate\"><span class=\"pre\">cargo-concordium</span></code> to build smart contracts.</p>", "a[href=\"#work-with-queries\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Work with queries<a class=\"headerlink\" href=\"#work-with-queries\" title=\"Link to this heading\">#</a></h3><p>Queries can be called from smart contracts to query an account balance, contract balance,\nor the current exchange rates.</p>", "a[href=\"#write-a-smart-contract-using-concordium-std\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Write a smart contract using <code class=\"docutils literal notranslate\"><span class=\"pre\">concordium_std</span></code><a class=\"headerlink\" href=\"#write-a-smart-contract-using-concordium-std\" title=\"Link to this heading\">#</a></h2><p>It is recommended to use the <code class=\"docutils literal notranslate\"><span class=\"pre\">concordium_std</span></code> crate, which provides a\nmore Rust-like experience for developing smart contract modules and calling\nhost functions.</p><p>The crate enables writing init and receive functions as simple Rust\nfunctions annotated with <code class=\"docutils literal notranslate\"><span class=\"pre\">#[init(...)]</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">#[receive(...)]</span></code>, respectively.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
