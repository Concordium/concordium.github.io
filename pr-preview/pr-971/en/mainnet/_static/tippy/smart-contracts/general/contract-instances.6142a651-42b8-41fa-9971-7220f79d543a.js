selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Trie\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/320px-Trie_example.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>In computer science, a <b>trie</b>, also called <b>digital tree</b> or <b>prefix tree</b>, is a type of <span><i>k</i>-ary</span> search tree, a tree data structure used for locating specific keys from within a set. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Trie#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/320px-Trie_example.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>In computer science, a <b>trie</b>, also called <b>digital tree</b> or <b>prefix tree</b>, is a type of <span><i>k</i>-ary</span> search tree, a tree data structure used for locating specific keys from within a set. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>", "a[href=\"#smart-contract-instances\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Smart contract instances<a class=\"headerlink\" href=\"#smart-contract-instances\" title=\"Link to this heading\">#</a></h1><p>A <a class=\"reference internal\" href=\"../../net/resources/glossary.html#term-Instance\"><span class=\"xref std std-term\">smart contract instance</span></a> is a smart contract module together with a\nspecific state and an amount of CCD tokens. A smart contract instance is often just called an <em>instance</em>.\nMultiple smart contract instances can be created from the same module.\nFor example, for an <a class=\"reference internal\" href=\"introduction.html#auction\"><span class=\"std std-ref\">auction</span></a> contract, there could be multiple instances, each\none dedicated to bidding for a specific item and with its own participants.</p><p>Smart contract instances can be created from a deployed <a class=\"reference internal\" href=\"contract-module.html#contract-module\"><span class=\"std std-ref\">smart contract\nmodule</span></a> via the <code class=\"docutils literal notranslate\"><span class=\"pre\">init</span></code> transaction which invokes the\nrequested function in the smart contract module. This function can take a\nparameter.\nIts end result is required to be the initial smart contract state of the\ninstance.</p>", "a[href=\"../guides/initialize-contract.html#initialize-contract\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Initialize a smart contract instance<a class=\"headerlink\" href=\"#initialize-a-smart-contract-instance\" title=\"Link to this heading\">#</a></h1><p>This guide will show you how to initialize a smart contract from a deployed\nsmart contract module with parameters in JSON or binary format.\nAdditionally, it will show how to name an instance.</p><p>You can also watch a video about initializing smart contract instances.</p>", "a[href=\"contract-module.html#contract-module\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Smart contract modules<a class=\"headerlink\" href=\"#smart-contract-modules\" title=\"Link to this heading\">#</a></h1><p>Smart contracts are deployed on the chain in <em>smart contract modules</em>. A smart contract module is often referred to simply as a <em>module</em>.</p><p>A module can contain one or more smart contracts, allowing code to be shared\namong the contracts and can optionally contain <a class=\"reference internal\" href=\"contract-schema.html#contract-schema\"><span class=\"std std-ref\">contract schemas</span></a> and verification data.</p>", "a[href=\"#interact-with-an-instance\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Interact with an instance<a class=\"headerlink\" href=\"#interact-with-an-instance\" title=\"Link to this heading\">#</a></h2><p>A smart contract can expose zero or more functions for interacting with an\ninstance, referred to as <em>receive functions</em>.</p><p>Just like with init functions, receive functions are triggered using\ntransactions, which contain some amount of CCD for the contract and an argument\nto the function in the form of bytes.</p>", "a[href=\"#limits\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Limits<a class=\"headerlink\" href=\"#limits\" title=\"Link to this heading\">#</a></h2><p>When initializing, updating, or invoking a smart contract, the following limits are enforced:</p>", "a[href=\"../references/host-fns.html#host-functions-log\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Logging events<a class=\"headerlink\" href=\"#logging-events\" title=\"Link to this heading\">#</a></h2>", "a[href=\"#log-events\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Log events<a class=\"headerlink\" href=\"#log-events\" title=\"Link to this heading\">#</a></h2><p>Events can be logged during the execution of smart contract functions. This is\nthe case for both init and receive functions. The logs are designed for\noff-chain use, so that actors outside of the chain can monitor the events and\nreact to them. Logs are not accessible to smart contracts, or any other actor on\nthe chain. Events can be logged using a function supplied by the host\nenvironment.</p>", "a[href=\"../guides/upgradeable-contract.html#guide-upgradable-contract\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Make a contract upgradeable<a class=\"headerlink\" href=\"#make-a-contract-upgradeable\" title=\"Link to this heading\">#</a></h1><p>This guide shows how to make a Rust smart contract upgradeable.</p><p>Immutable smart contracts come with the drawback that bugs cannot be fixed, new features and cost optimizations cannot be implemented.\nFor some decentralized applications this is a problem and these need some way to upgrade the smart contract code.</p>", "a[href=\"#instantiate-a-smart-contract-on-chain\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Instantiate a smart contract on-chain<a class=\"headerlink\" href=\"#instantiate-a-smart-contract-on-chain\" title=\"Link to this heading\">#</a></h2><p>Every smart contract must contain a function for creating smart contract\ninstances. Such a function is referred to as the <em>init function</em>.</p><p>To create a smart contract instance, an account sends a special transaction with\na reference to the deployed smart contract module and the name of the\ninit function to use for instantiation.</p>", "a[href=\"../../net/resources/glossary.html#term-Instance\"]": "<dt id=\"term-Instance\">Instance</dt><dd><p>A smart contract module together with a specific state and an amount of CCD tokens. Multiple smart contract instances can be created from the same module. Smart contract instances can be created from a deployed <a class=\"reference internal\" href=\"../../smart-contracts/general/contract-module.html#contract-module\"><span class=\"std std-ref\">smart contract module</span></a> via the <code class=\"docutils literal notranslate\"><span class=\"pre\">init</span></code> transaction which invokes the requested function in the smart contract module. This function can take a parameter. Its end result is the state of the smart contract instance.</p></dd>", "a[href=\"#state-of-a-smart-contract-instance\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">State of a smart contract instance<a class=\"headerlink\" href=\"#state-of-a-smart-contract-instance\" title=\"Link to this heading\">#</a></h2><p>The state of a smart contract instance consists of two parts, the user-defined\nstate and the amount of CCD the contract holds, i.e., its <em>balance</em>. When\nreferring to state it typically means only the user-defined state. The reason for\ntreating the CCD amount separately is that CCD can only be spent and\nreceived according to rules of the network, e.g., contracts cannot create\nor destroy CCD tokens.</p>", "a[href=\"#failing-to-upgrade\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Failing to upgrade<a class=\"headerlink\" href=\"#failing-to-upgrade\" title=\"Link to this heading\">#</a></h3><p>A smart contract instance can fail to upgrade for one of the following reasons:</p>", "a[href=\"#invoke-operations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Invoke operations<a class=\"headerlink\" href=\"#invoke-operations\" title=\"Link to this heading\">#</a></h2><p>A receive function can use the host environment to invoke two types of\noperations during its execution.\nThe possible operations that a contract can perform are:</p>", "a[href=\"#immutability\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Immutability<a class=\"headerlink\" href=\"#immutability\" title=\"Link to this heading\">#</a></h3><p>Only the smart contract itself can trigger an upgrade of its module, meaning that smart contracts\nare immutable when they do not contain any code for triggering an upgrade.</p>", "a[href=\"#instance-state\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Instance state<a class=\"headerlink\" href=\"#instance-state\" title=\"Link to this heading\">#</a></h2><p>Every smart contract instance holds its own state which is represented on-chain\nas a <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Trie\">prefix tree</a>, where nodes in the\ntree can have data in the form of a byte array.\nThe instance uses functions provided by the host environment to create, delete,\nand find nodes in the tree.\nThe host also provides functions for reading, writing, and resizing the byte array\nheld by a particular node in the tree.</p>", "a[href=\"../references/host-fns.html#host-functions-state\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Smart contract instance state<a class=\"headerlink\" href=\"#smart-contract-instance-state\" title=\"Link to this heading\">#</a></h2>", "a[href=\"introduction.html#auction\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Auction smart contract example<a class=\"headerlink\" href=\"#auction-smart-contract-example\" title=\"Link to this heading\">#</a></h2><p>A use case for smart contracts could be for holding an auction; here you program\nthe smart contract to accept different bids from anyone and have it keep track\nof the highest bidder.\nWhen the auction is over, the smart contract sends the winner bid CCD to the seller and all other bids back. The seller then should send the item to the winner.</p><p>The smart contract replaces the main role of the auctioneer. The contract itself\nonly governs the bidding part, and the on-chain distribution of CCDs. It will\nlikely also need some logic for reimbursing the highest bidder if the seller\ndoes not fulfil their obligations. This will most likely mean that the contract\nneeds to support some notion of proof that the seller has indeed fulfilled their\nobligation, or some way for the highest bidder to file a complaint. Smart\ncontracts cannot resolve these real-world issues automatically, and the best\nsolution is likely going to depend on the specifics of the auction.</p>", "a[href=\"#upgradeability\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Upgradeability<a class=\"headerlink\" href=\"#upgradeability\" title=\"Link to this heading\">#</a></h2><p>A V1 smart contract instance can choose to upgrade its module to a new V1 smart contract\nmodule using the <strong>upgrade</strong> host function.\nThe host function takes a reference to a deployed smart contract module to use for\nthe upgraded instance and can only be called from a receive function.\nThe host function returns whether the upgrade succeeded, allowing the instance\nto decide the next step. If the upgrade is successful any new invocations of the\nupgraded instance uses the smart contract code in the new module.</p>", "a[href=\"#migration\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Migration<a class=\"headerlink\" href=\"#migration\" title=\"Link to this heading\">#</a></h3><p>Triggering a smart contract instance upgrade changes the smart contract module starting from the next\ninvocation, meaning the execution will continue after the point of calling upgrade.\nSince any new invocation of this instance uses the new smart contract module, the instance\ncan invoke itself and run code of the new module in the same transaction containing the upgrade.\nThis is useful for triggering a migration function in the new smart contract module and rejecting the\nupgrade if the migration fails.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
