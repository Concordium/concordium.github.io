selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/The_DAO_(organization)\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Christoph_Jentzsch.jpg/320px-Christoph_Jentzsch.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p><b>The DAO</b> was a digital decentralized autonomous organization and a form of investor-directed venture capital fund. After launching in April 2016 via a token sale, it became one of the largest crowdfunding campaigns in history, but it ceased activity after much of its funds were taken in a hack in June 2016.</p>", "a[href^=\"https://en.wikipedia.org/wiki/The_DAO_(organization)#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Christoph_Jentzsch.jpg/320px-Christoph_Jentzsch.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p><b>The DAO</b> was a digital decentralized autonomous organization and a form of investor-directed venture capital fund. After launching in April 2016 via a token sale, it became one of the largest crowdfunding campaigns in history, but it ceased activity after much of its funds were taken in a hack in June 2016.</p>", "a[href=\"#denial-of-service\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Denial-of-service<a class=\"headerlink\" href=\"#denial-of-service\" title=\"Link to this heading\">#</a></h3><p>This section presents situations when a smart contract ends up in a blocked state making it unusable permanently or for some period of time.</p>", "a[href=\"#recommended-structure\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Recommended structure<a class=\"headerlink\" href=\"#recommended-structure\" title=\"Link to this heading\">#</a></h3>", "a[href=\"#external-calls\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">External Calls<a class=\"headerlink\" href=\"#external-calls\" title=\"Link to this heading\">#</a></h3><p>Treat every external call as a potential security risk.\nCalling another contract gives control to potentially malicious code that could make arbitrary calls to any other contract, including your own contract.\nCalls to your contract might change its state through entrypoints that permit updating the state; see the <a class=\"reference internal\" href=\"#best-practices-reentrancy\"><span class=\"std std-ref\">Reentrancy</span></a> section of this document.\nMoreover, you should not make any assumptions about energy consumption, or expect that the execution succeeds.\nYour contract should be able to correctly handle situations when the call to an external contract fails.</p>", "a[href=\"#best-practices-external-call-failure\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">External call failure<a class=\"headerlink\" href=\"#external-call-failure\" title=\"Link to this heading\">#</a></h4><p>Sending funds back to an unknown contract address as part of some complex operation could block this operation from succeeding.\nThe contract you call might fail for various reasons.\nIf the contract call fails, the whole operation also fails.</p><p>Consider splitting withdrawal of funds from the rest of the contract logic.\nYou could create a separate entrypoint allowing users, which could be smart contracts, to request funds back.\nThis pattern is called <em>Pull over Push</em>, where <em>Pull</em> corresponds to the user explicitly requesting funds and <em>Push</em> to sending the funds back as part of some other operation.</p>", "a[href=\"#specification\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Specification<a class=\"headerlink\" href=\"#specification\" title=\"Link to this heading\">#</a></h2><p>A smart contract specification reflects developers\u2019 intentions regarding the smart contract functionality.\nIt can serve as a guide for the implementation as well as for testing, verifying, and auditing the code.\nStart with an outline of the functionality and gradually refine it into specifications of contract entrypoints.</p><p>For the entrypoints, consider the following:</p>", "a[href=\"#general-recommendations\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">General recommendations<a class=\"headerlink\" href=\"#general-recommendations\" title=\"Link to this heading\">#</a></h4>", "a[href=\"#operations-with-unknown-bound\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">Operations with unknown bound<a class=\"headerlink\" href=\"#operations-with-unknown-bound\" title=\"Link to this heading\">#</a></h4><p>Interacting over data structures that store data updated by users can become expensive over time, once it has more and more entries.</p><p>Consider the following map for storing all user bids in an auction contract:</p>", "a[href=\"../general/contract-instances.html#contract-instance-upgradeability\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Upgradeability<a class=\"headerlink\" href=\"#upgradeability\" title=\"Link to this heading\">#</a></h2><p>A V1 smart contract instance can choose to upgrade its module to a new V1 smart contract\nmodule using the <strong>upgrade</strong> host function.\nThe host function takes a reference to a deployed smart contract module to use for\nthe upgraded instance and can only be called from a receive function.\nThe host function returns whether the upgrade succeeded, allowing the instance\nto decide the next step. If the upgrade is successful any new invocations of the\nupgraded instance uses the smart contract code in the new module.</p>", "a[href=\"../general/contract-instances.html#contract-instances-logging-events\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Log events<a class=\"headerlink\" href=\"#log-events\" title=\"Link to this heading\">#</a></h2><p>Events can be logged during the execution of smart contract functions. This is\nthe case for both init and receive functions. The logs are designed for\noff-chain use, so that actors outside of the chain can monitor the events and\nreact to them. Logs are not accessible to smart contracts, or any other actor on\nthe chain. Events can be logged using a function supplied by the host\nenvironment.</p>", "a[href=\"#concordium-rust-smart-contracts\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Concordium Rust Smart Contracts<a class=\"headerlink\" href=\"#concordium-rust-smart-contracts\" title=\"Link to this heading\">#</a></h2><p>This section provides recommendations for developing smart contracts in Rust.\nSee <a class=\"reference internal\" href=\"../general/introduction.html#introduction\"><span class=\"std std-ref\">Introduction to smart contracts</span></a> for basic information.</p>", "a[href=\"../guides/unit-test-contract.html#unit-test-contract\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Unit test a contract in Rust<a class=\"headerlink\" href=\"#unit-test-a-contract-in-rust\" title=\"Link to this heading\">#</a></h1><p>This guide describes how to write unit tests for a smart contract written in\nRust.\nFor information about how to test a smart contract Wasm module, see <a class=\"reference internal\" href=\"../guides/local-simulate.html#local-simulate\"><span class=\"std std-ref\">Locally simulate contract functions</span></a>.</p><p>A smart contract in Rust is written as a library and you can unit test it like a\nlibrary by annotating functions with a <code class=\"docutils literal notranslate\"><span class=\"pre\">#[test]</span></code> attribute.</p>", "a[href=\"../guides/unit-test-contract.html#writing-property-based-tests\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Writing property-based tests<a class=\"headerlink\" href=\"#writing-property-based-tests\" title=\"Link to this heading\">#</a></h2><p>The property-based testing technique allows for testing statements about your code that are expected to be true for any input parameters, possibly satisfying some precondition.\nYou can think of a precondition and a property as functions returning a boolean.\nThat is, for a function <code class=\"docutils literal notranslate\"><span class=\"pre\">fun</span></code>, a property looks as the following: \u201cfor any input <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">y</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">z</span></code>, such that <code class=\"docutils literal notranslate\"><span class=\"pre\">precondition(x,</span> <span class=\"pre\">y,</span> <span class=\"pre\">z)</span> <span class=\"pre\">=</span> <span class=\"pre\">true</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">property(x,</span> <span class=\"pre\">y,</span> <span class=\"pre\">z,</span> <span class=\"pre\">fun(x,y,z))</span> <span class=\"pre\">=</span> <span class=\"pre\">true</span></code>\u201d.\nThe input to such tests is generated randomly.\nAn example of a property is \u201cfor any integers <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>, such that <code class=\"docutils literal notranslate\"><span class=\"pre\">even(n)</span> <span class=\"pre\">=</span> <span class=\"pre\">true</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">even(m)</span> <span class=\"pre\">=</span> <span class=\"pre\">true</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">even(n</span> <span class=\"pre\">+</span> <span class=\"pre\">m)</span> <span class=\"pre\">=</span> <span class=\"pre\">true</span></code>\u201d.</p><p>Property-based testing is supported using the <a class=\"reference external\" href=\"https://docs.rs/quickcheck/latest/quickcheck\"><code class=\"docutils literal notranslate\"><span class=\"pre\">QuickCheck</span></code></a> crate.\nThe tests should be placed in the same module as regular unit tests and annotated with the <code class=\"docutils literal notranslate\"><span class=\"pre\">#[concordium_quickcheck]</span></code> macro.\nThe return value of the function should be a boolean corresponding to whether the property holds.</p>", "a[href=\"#best-practices-reentrancy\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">Reentrancy<a class=\"headerlink\" href=\"#reentrancy\" title=\"Link to this heading\">#</a></h4><p>The <em>reentrant behavior</em> is not specific to smart contracts: it is a well known issue in the context of concurrency.\nA procedure can be interrupted in the middle of its execution, run again in <em>another</em> execution context, and then continue execution from the interruption point.\nIn case of smart contracts, each call to external smart contracts interrupts the execution and hands over control to unknown code.\nDo not treat external contract invocations as regular method calls.\nInstead, think of them as sending a message and temporarily pausing execution of your contract.\nThe receiving side has full control of what to do next and can choose to call your contract again while it is still in the \u201cpaused\u201d state waiting for the external call to be completed.\nOnce the external call is completed, the contract state and balance might be different from those before the call.\nSee an <a class=\"reference internal\" href=\"../guides/unit-test-contract.html#reentracny-unit-testing\"><span class=\"std std-ref\">example</span></a> based on <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/The_DAO_(organization)\">the DAO</a> Ethereum smart contract vulnerability of how reentrancy can be discovered using unit testing.</p>", "a[href=\"#checklist\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Checklist<a class=\"headerlink\" href=\"#checklist\" title=\"Link to this heading\">#</a></h3><p>Make sure that:</p>", "a[href=\"#code-documentation\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Code documentation<a class=\"headerlink\" href=\"#code-documentation\" title=\"Link to this heading\">#</a></h3>", "a[href=\"#best-practices-code-automated-testing\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Automated testing<a class=\"headerlink\" href=\"#automated-testing\" title=\"Link to this heading\">#</a></h3><p>The Concordium standard library <a class=\"reference external\" href=\"https://docs.rs/concordium-std/latest/concordium_std/\">concordium-std</a> offers several possibilities for testing the smart contract code.</p>", "a[href=\"#automated-testing\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Automated testing<a class=\"headerlink\" href=\"#automated-testing\" title=\"Link to this heading\">#</a></h3><p>The Concordium standard library <a class=\"reference external\" href=\"https://docs.rs/concordium-std/latest/concordium_std/\">concordium-std</a> offers several possibilities for testing the smart contract code.</p>", "a[href=\"../guides/unit-test-contract.html#reentracny-unit-testing\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Reentrancy<a class=\"headerlink\" href=\"#reentrancy\" title=\"Link to this heading\">#</a></h3><p>When invoking another smart contract, you give away control to that contract in the middle of execution.\nThe external contract can, for example, call back entrypoints of your contract.\nThis behavior is called <em>reentrancy</em> and is well-known from concurrency: a procedure can be interrupted in the middle of its execution, called again, and then resume execution.\nSee the details about handling external calls and ways of protecting against reentrancy-related issues in the <a class=\"reference internal\" href=\"../best-practices/development.html#best-practices-external-calls\"><span class=\"std std-ref\">development best practices</span></a>.</p><p>The state of your contract might not be the same before and after <code class=\"docutils literal notranslate\"><span class=\"pre\">invoke_contract</span></code>, since the contract you call can invoke any entrypoint of your own contract.</p>", "a[href=\"../general/contract-instances.html#contract-instance-operations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Limits<a class=\"headerlink\" href=\"#limits\" title=\"Link to this heading\">#</a></h2><p>When initializing, updating, or invoking a smart contract, the following limits are enforced:</p>", "a[href=\"#reentrancy\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">Reentrancy<a class=\"headerlink\" href=\"#reentrancy\" title=\"Link to this heading\">#</a></h4><p>The <em>reentrant behavior</em> is not specific to smart contracts: it is a well known issue in the context of concurrency.\nA procedure can be interrupted in the middle of its execution, run again in <em>another</em> execution context, and then continue execution from the interruption point.\nIn case of smart contracts, each call to external smart contracts interrupts the execution and hands over control to unknown code.\nDo not treat external contract invocations as regular method calls.\nInstead, think of them as sending a message and temporarily pausing execution of your contract.\nThe receiving side has full control of what to do next and can choose to call your contract again while it is still in the \u201cpaused\u201d state waiting for the external call to be completed.\nOnce the external call is completed, the contract state and balance might be different from those before the call.\nSee an <a class=\"reference internal\" href=\"../guides/unit-test-contract.html#reentracny-unit-testing\"><span class=\"std std-ref\">example</span></a> based on <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/The_DAO_(organization)\">the DAO</a> Ethereum smart contract vulnerability of how reentrancy can be discovered using unit testing.</p>", "a[href=\"#mindset\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Mindset<a class=\"headerlink\" href=\"#mindset\" title=\"Link to this heading\">#</a></h2><p>Smart contract development involves many risks that do not show up in, for example, web programming:</p>", "a[href=\"#best-practices-code-structure\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Recommended structure<a class=\"headerlink\" href=\"#recommended-structure\" title=\"Link to this heading\">#</a></h3>", "a[href=\"#external-call-failure\"]": "<h4 class=\"tippy-header\" style=\"margin-top: 0;\">External call failure<a class=\"headerlink\" href=\"#external-call-failure\" title=\"Link to this heading\">#</a></h4><p>Sending funds back to an unknown contract address as part of some complex operation could block this operation from succeeding.\nThe contract you call might fail for various reasons.\nIf the contract call fails, the whole operation also fails.</p><p>Consider splitting withdrawal of funds from the rest of the contract logic.\nYou could create a separate entrypoint allowing users, which could be smart contracts, to request funds back.\nThis pattern is called <em>Pull over Push</em>, where <em>Pull</em> corresponds to the user explicitly requesting funds and <em>Push</em> to sending the funds back as part of some other operation.</p>", "a[href=\"#development-best-practices\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Development best practices<a class=\"headerlink\" href=\"#development-best-practices\" title=\"Link to this heading\">#</a></h1><p>This document provides guidelines for developing smart contracts, including best practices for smart contract development, audit, information about common pitfalls and security vulnerabilities, and how to avoid them.</p><p>It starts with some general thoughts about smart contract development and then gives more details about writing smart contracts in Rust for Concordium.</p>", "a[href=\"#best-practices-external-calls\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">External Calls<a class=\"headerlink\" href=\"#external-calls\" title=\"Link to this heading\">#</a></h3><p>Treat every external call as a potential security risk.\nCalling another contract gives control to potentially malicious code that could make arbitrary calls to any other contract, including your own contract.\nCalls to your contract might change its state through entrypoints that permit updating the state; see the <a class=\"reference internal\" href=\"#best-practices-reentrancy\"><span class=\"std std-ref\">Reentrancy</span></a> section of this document.\nMoreover, you should not make any assumptions about energy consumption, or expect that the execution succeeds.\nYour contract should be able to correctly handle situations when the call to an external contract fails.</p>", "a[href=\"#best-practices-code-documentation\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Code documentation<a class=\"headerlink\" href=\"#code-documentation\" title=\"Link to this heading\">#</a></h3>", "a[href=\"#best-practices-specification\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Specification<a class=\"headerlink\" href=\"#specification\" title=\"Link to this heading\">#</a></h2><p>A smart contract specification reflects developers\u2019 intentions regarding the smart contract functionality.\nIt can serve as a guide for the implementation as well as for testing, verifying, and auditing the code.\nStart with an outline of the functionality and gradually refine it into specifications of contract entrypoints.</p><p>For the entrypoints, consider the following:</p>", "a[href=\"../guides/integration-test-contract.html#integration-test-contract\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Integration test a contract in Rust<a class=\"headerlink\" href=\"#integration-test-a-contract-in-rust\" title=\"Link to this heading\">#</a></h1><p>This guide describes how to write <em>integration tests</em> in Rust for your smart contracts using the <a class=\"reference external\" href=\"https://docs.rs/concordium-smart-contract-testing/latest/concordium_smart_contract_testing/\">Concordium smart contract testing library</a>.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
